// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc103.Cyber103.commands;

import edu.wpi.first.wpilibj.RobotDrive.MotorType;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import org.usfirst.frc103.Cyber103.Robot;
import org.usfirst.frc103.Cyber103.RobotMap;

/**
 *
 */
public class  RC extends Command {
	
	private enum State {
		WAIT, GRAB_BIN, LIFT_BIN, DRIVE_TO_TOTE, LOWER_BIN, RELEASE_BIN, LOWER_TOWER, GRAB_TOTE, LIFT_TOTE, TURN_LEFT, DRIVE_TO_ZONE, DONE
	}
	private static final double
	BIN_LIFT_POSITION = 0.325,
	TOTE_DISTANCE = 200,
	BIN_LOWER_POSITION = 0.2,
	TOWER_LOWER_POSITION = 0.06,
	TOTE_LIFT_POSITION = 0.2,
	TURN_DISTANCE = 200,
	ZONE_DISTANCE = 1150;
	
	private State state;
	private State nextState;
	private Timer waitTimer = new Timer();
	private double waitDuration;
	private boolean done;
	
	private void addWait(double duration, State next) {
		state = State.WAIT;
		nextState = next;
		waitDuration = duration;
		waitTimer.reset();
		waitTimer.start();
	}

    public RC() {
        // Use requires() here to declare subsystem dependencies
        // eg. requires(chassis);

        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    }

    // Called just before this Command runs the first time
    protected void initialize() {
    	Robot.driveTrain.rcInitCom();
    	state = State.GRAB_BIN;
    	done = false;
    	RobotMap.driveTrainRobotDrive.setInvertedMotor(MotorType.kFrontLeft, false);
    	RobotMap.driveTrainRobotDrive.setInvertedMotor(MotorType.kRearLeft, false);
    	RobotMap.driveTrainRobotDrive.setInvertedMotor(MotorType.kFrontRight, false);
    	RobotMap.driveTrainRobotDrive.setInvertedMotor(MotorType.kRearRight, false);
    	RobotMap.driveTrainDriveEncoderLeft.setReverseDirection(true);
    	RobotMap.driveTrainDriveEncoderRight.setReverseDirection(true);
    }

    // Called repeatedly when this Command is scheduled to run
    protected void execute() {
    	switch (state) {
    	case WAIT: {
    		//SmartDashboard.putString("current state", state.name());
    		if (waitTimer.hasPeriodPassed(waitDuration)) {
    			state = nextState;
    		}
    		break;
    	}
    	case GRAB_BIN: {
    		//SmartDashboard.putString("current state", state.name());
    		Robot.armGrabber.close();
    		addWait(0.5, State.LIFT_BIN);
    		break;
    	}
    	case LIFT_BIN: {
    		//SmartDashboard.putString("current state", state.name());
    		double position = RobotMap.liftAnalogPot.get();
    		if (position < BIN_LIFT_POSITION) {
        		RobotMap.liftLiftController.set(0.5);
    		} else {
        		RobotMap.liftLiftController.set(0.0);
        		RobotMap.driveTrainDriveEncoderLeft.reset();
        		RobotMap.driveTrainDriveEncoderRight.reset();
        		addWait(0.5, State.DRIVE_TO_TOTE);
        		//state = State.DRIVE_TO_TOTE;
    		}
    		break;
    	}
    	case DRIVE_TO_TOTE: {
    		//SmartDashboard.putString("current state", state.name());
    		double leftPosition = RobotMap.driveTrainDriveEncoderLeft.getDistance();
    		double rightPosition = -RobotMap.driveTrainDriveEncoderRight.getDistance();
    		//SmartDashboard.putNumber("left encoder", leftPosition);
    		//SmartDashboard.putNumber("right encoder", rightPosition);
    		if (leftPosition < TOTE_DISTANCE || rightPosition < TOTE_DISTANCE) {
    			RobotMap.driveTrainRobotDrive.tankDrive(0.5, 0.5);
    		} else {
    			RobotMap.driveTrainRobotDrive.tankDrive(0.0, 0.0);
        		addWait(0.5, State.LOWER_BIN);
    			//state = State.LOWER_BIN;
    		}
    		break;
    	}
    	case LOWER_BIN: {
    		//SmartDashboard.putString("current state", state.name());
    		double position = RobotMap.liftAnalogPot.get();
    		if (position > BIN_LOWER_POSITION) {
        		RobotMap.liftLiftController.set(-0.5);
    		} else {
        		RobotMap.liftLiftController.set(0.0);
        		addWait(0.5, State.RELEASE_BIN);
        		//state = State.RELEASE_BIN;
    		}
    		break;
    	}
    	case RELEASE_BIN: {
    		//SmartDashboard.putString("current state", state.name());
    		Robot.armGrabber.open();
    		addWait(0.5, State.LOWER_TOWER);
    		break;
    	}
    	case LOWER_TOWER: {
    		//SmartDashboard.putString("current state", state.name());
    		double position = RobotMap.liftAnalogPot.get();
    		if (position > TOWER_LOWER_POSITION) {
        		RobotMap.liftLiftController.set(-0.25);
    		} else {
        		RobotMap.liftLiftController.set(0.0);
        		addWait(0.5, State.GRAB_TOTE);
        		//state = State.GRAB_TOTE;
    		}
    		break;
    	}
    	case GRAB_TOTE: {
    		//SmartDashboard.putString("current state", state.name());
    		Robot.armGrabber.close();
    		addWait(1.0, State.LIFT_TOTE);
    		break;
    	}
    	case LIFT_TOTE: {
    		//SmartDashboard.putString("current state", state.name());
    		double position = RobotMap.liftAnalogPot.get();
    		if (position < TOTE_LIFT_POSITION) {
        		RobotMap.liftLiftController.set(0.5);
    		} else {
        		RobotMap.liftLiftController.set(0.0);
        		RobotMap.driveTrainDriveEncoderLeft.reset();
        		RobotMap.driveTrainDriveEncoderRight.reset();
        		addWait(0.5, State.TURN_LEFT);
        		//state = State.TURN_LEFT;
    		}
    		break;
    	}
    	case TURN_LEFT: {
    		//SmartDashboard.putString("current state", state.name());
    		double leftPosition = RobotMap.driveTrainDriveEncoderLeft.getDistance();
    		double rightPosition = -RobotMap.driveTrainDriveEncoderRight.getDistance();
    		SmartDashboard.putNumber("left encoder", leftPosition);
    		SmartDashboard.putNumber("right encoder", rightPosition);
    		if (leftPosition > -TURN_DISTANCE && rightPosition < TURN_DISTANCE) {
    			RobotMap.driveTrainRobotDrive.tankDrive(-0.6, 0.6);
    		} else {
    			RobotMap.driveTrainRobotDrive.tankDrive(0.0, 0.0);
        		RobotMap.driveTrainDriveEncoderLeft.reset();
        		RobotMap.driveTrainDriveEncoderRight.reset();
        		addWait(0.5, State.DRIVE_TO_ZONE);
    			//state = State.DRIVE_TO_ZONE;
    		}
    		break;
    	}
    	case DRIVE_TO_ZONE: {
    		//SmartDashboard.putString("current state", state.name());
    		double leftPosition = RobotMap.driveTrainDriveEncoderLeft.getDistance();
    		double rightPosition = -RobotMap.driveTrainDriveEncoderRight.getDistance();
    		SmartDashboard.putNumber("left encoder", leftPosition);
    		SmartDashboard.putNumber("right encoder", rightPosition);
    		if (leftPosition < ZONE_DISTANCE && rightPosition < ZONE_DISTANCE) {
    			RobotMap.driveTrainRobotDrive.tankDrive(0.75, 0.75);
    		} else {
    			RobotMap.driveTrainRobotDrive.tankDrive(0.0, 0.0);
        		addWait(0.5, State.DONE);
    			//state = State.DONE;
    		}
    		break;
    	}
    	case DONE: {
    		//SmartDashboard.putString("current state", state.name());
    		done = true;
    		break;
    	}
    	}
    }

    // Make this return true when this Command no longer needs to run execute()
    protected boolean isFinished() {
        return done;
    }

    // Called once after isFinished returns true
    protected void end() {
    	Robot.driveTrain.rcComStop();
    	RobotMap.driveTrainRobotDrive.setInvertedMotor(MotorType.kFrontLeft, true);
    	RobotMap.driveTrainRobotDrive.setInvertedMotor(MotorType.kRearLeft, true);
    	RobotMap.driveTrainRobotDrive.setInvertedMotor(MotorType.kFrontRight, true);
    	RobotMap.driveTrainRobotDrive.setInvertedMotor(MotorType.kRearRight, true);
    	RobotMap.driveTrainDriveEncoderLeft.setReverseDirection(false);
    	RobotMap.driveTrainDriveEncoderRight.setReverseDirection(false);
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    protected void interrupted() {
    	end();
    }
}
